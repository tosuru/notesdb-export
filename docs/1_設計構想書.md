# NotesDB変換パイプライン 設計構想書

バージョン: 1.0.0
作成日: 2025-10-23 

## 1. プロジェクト概要

### 1.1. 目的

本プロジェクトの目的は、クローズドなNotesDB（DXL形式）の情報を、持続可能かつ再利用可能な形に変換し、多様なドキュメント形式（HTML, DOCX, PDF, Markdown）および将来的なデータ活用（全文検索、機械学習）のための安定した資産として提供することにある。

### 1.2. 背景

従来の変換プロセスでは、特定の処理モジュールへの責務集中や、出力形式ごと（DOCX, PDF）のレンダリングロジックの重複が発生していた。  
プロジェクトが進行し、Notesリッチテキストの再現性（runs）の要求が高まるにつれ、この構成が保守性・拡張性のボトルネックとなりつつある。  
本構想は、これらの課題を解消し、「疎結合」「責務の分離」「再利用性」を最大化するアーキテクチャへの再設計を定義するものである。

## 2. 基本アーキテクチャ方針

本プロジェクトは、以下の3つの方針を中核とする。

### 2.1. 中間フォーマット中心設計 (Intermediate-First)

* すべての変換プロセスの中心に、情報損失を最小限に抑えた「正規化JSON (normalized.json)」を据える。  
* DXLパーサーは「DXL -> JSON」の生成にのみ責務を持ち、レンダラーは「JSON -> 目的形式」の変換にのみ責務を持つ。

### 2.2. 疎結合パイプライン (Decoupled Pipeline)

* Notesエクスポート、DXL正規化、添付ファイル抽出、レンダリング の各ステップを、独立して実行可能なモジュール群として構成する。  
* これにより、Unified（一気通貫）実行とDecoupled（ステップ別）実行の両方をサポートし、柔軟な運用（例：JSON生成済みデータへの再レンダリング）を可能にする。

### 2.3. 責務の分離 (Separation of Concerns)

* 機能単位でモジュールを明確に分離する。  
  * 課題A: パイプライン の責務過多（DXLエクスポート、JSON生成、添付抽出、レンダリング指示）。  
  * 対策A: 添付ファイル処理を core.attachments モジュールとして独立させ、パイプラインから呼び出す形態に変更する。  
  * 課題B: DOCX/PDFレンダラー間での runs 解釈ロジックの重複。  
  * 対策B: core.render 内に共通の「runs ハンドラ/ビジター層」を設け、runs 配列の解釈を一元化する。

## 3. コアモジュール構成と責務

上記方針に基づき、src 配下のモジュール構成と責務を以下のように再定義する。

### 3.1. core.dxl.parser (DXL解析モジュール)

* 責務: DXL (XML) を入力とし、normalized.json スキーマ仕様に準拠したPythonオブジェクト（またはJSON）を生成する。  
* 機能:  
  * DXL名前空間の解釈。  
  * 文書メタデータ（UNID, Form, 日時等）の抽出。  
  * リッチテキストの解析と runs 配列（スタイル、リンク、テーブル構造を含む）への変換。  
  * 添付ファイル・埋め込み画像のメタデータ抽出（実体のデコードは行わない）。

### 3.2. core.render (レンダリングエンジン)

* 責務: normalized.json オブジェクトを入力とし、指定された形式（HTML, DOCX, PDF, MD）のファイルを生成する。  
* 設計指針 (重要):  
  * 共通ハンドラ層: runs 配列（text, br, link, img, table 等）を解釈する共通のビジター（Visitor）またはハンドラロジックを実装する。  
  * 各エンジン:  
    * html.py / md.py: 共通ハンドラを介して解釈されたデータをJinja2テンプレートに渡し、テキストベースの出力を生成する。  
    * docx.py / pdf.py: 共通ハンドラからのコールバックを受け、python-docx や reportlab のオブジェクトを構築する。これにより、runs の解釈ロジックの重複を排除する。  
  * utils.font と連携し、共通のフォント設定を適用する。

### 3.3. core.attachments (添付ファイル処理モジュール)

* 責務: DXLファイル（または normalized.json メタ）を入力とし、埋め込まれたBase64等のデータをデコードし、指定されたディレクトリに実ファイルとして保存する。  
* 設計指針:  
  * pipelines モジュールから呼び出される独立したコンポーネントとする。  
  * normalized.json の attachments メタ情報（ファイル名、OID等）とDXLの実データを照合して処理を実行する。

### 3.4. pipelines (パイプライン制御モジュール)

* 責務: NotesDB連携など、複数のコアモジュールをまたぐ複雑な実行フローを「ライブラリ」として提供する。
* 主要モジュール:

  * pipelines/flows.py:
    * main.py から呼び出されることを前提としたライブラリ。
    * run_unified: Unified（一気通貫）モードの実行フローを提供。
    * run_from_manifest: Manifest JSON（複数DB）の解釈と実行フローを提供。
    * run_decoupled_export: DXLエクスポートの実行フローを提供。

### 3.5. utils (共通ユーティリティ)

* progress_jsonl.py: JSONLによる軽量な進捗・状態管理（中断・再開）。  
* font.py: FONT_PATHの解決と各レンダラー（ReportLab, HTML）へのフォント登録。  
* config.py: 出力設定フラグの管理。

### 3.6. main.py (CLI司令塔)

* 責務: プロジェクトの唯一のコマンドラインエントリーポイント。  
* 機能:  
  * run-profile: launch.json に基づくプロファイル実行を管理する。  
  * サブコマンドの提供:  
    * run-manifest, run-single-db: 統合実行（pipelines.flows を呼び出す）。  
    * export: DecoupledモードのDXLエクスポート（pipelines.flows を呼び出す）。  
    * normalize, extract, render: Decoupledモードの各ステップ（core モジュールを直接呼び出す）。


## 4. データフローと拡張性

### 4.1. データフロー

1. 入力: main.py がコマンドライン引数（サブコマンド）または launch.json (プロファイル) を解釈。  
2. 制御 (統合実行):  
   * main.py (run-manifest等) が pipelines.flows の関数を呼び出す。  
   * pipelines.flows が notes.client → core.dxl.parser → core.attachments → core.render の順で処理を実行する。  
3. 制御 (分離実行):  
   * main.py normalize が core.dxl.parser を実行。  
   * main.py extract が core.attachments を実行。  
   * main.py render が core.render を実行。  
4. 状態管理: utils.progress_jsonl が処理対象（UNID）の進捗を記録。  
5. 出力: 指定されたディレクトリ構成に基づき、成果物（JSON, HTML, DOCX, PDF, 添付ファイル）を配置する。

### 4.2. 拡張性

* ML（機械学習）連携:  
  * normalized.json の Body.text（プレーンテキスト）または Body.runs（構造化テキスト）を、直接MLの学習データセットや分析インプットとして利用できる。  
* 新フォーマットの追加:  
  * core.render に新しいエンジン（例: xml.py）と、共通ハンドラに対応する処理を追加するだけで、runs 解釈ロジックを再実装することなく新フォーマットに対応可能。

## 5. 運用・保守

* 実行管理: launch.json (プロファイル) により、日常の実行設定（Manifestの場所、出力先、ログレベル等）を容易に切り替える。  
* 進捗管理: dist/state/ 配下の JSONL ファイルにより、大規模なバッチ処理の中断・再開をサポートする。  
* 品質保証: GitHub Actions (CI) によるスモークテスト（縦貫実行）および、make golden-diff によるゴールデン比較（リグレッションテスト）を継続的に実施する。